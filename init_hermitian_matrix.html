

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Initialization of Hermitian Matrices in MatrixConfigurationTrainer &mdash; Quantum Geometric Machine Learning (QGML) 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="_static/custom.css" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=8d563738"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #2980B9" >

          
          
          <a href="index.html" class="icon icon-home">
            Quantum Geometric Machine Learning (QGML)
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="user_guide/installation.html">QGML Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="user_guide/quickstart.html">QGML Quickstart Guide</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Visualizations</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="visualization_gallery.html">QGML Visualization Gallery</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="api/core.html">Core QGML Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="api/quantum_geometry.html">Quantum Geometry Trainer API</a></li>
<li class="toctree-l1"><a class="reference internal" href="api/topological_analysis.html">Topological Analysis API</a></li>
<li class="toctree-l1"><a class="reference internal" href="api/quantum_information.html">Quantum Information Analysis API</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Experimental Results</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="experimental_results/index.html">QGML Integration Experimental Results</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #2980B9" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Quantum Geometric Machine Learning (QGML)</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Initialization of Hermitian Matrices in MatrixConfigurationTrainer</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/init_hermitian_matrix.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="initialization-of-hermitian-matrices-in-matrixconfigurationtrainer">
<h1>Initialization of Hermitian Matrices in MatrixConfigurationTrainer<a class="headerlink" href="#initialization-of-hermitian-matrices-in-matrixconfigurationtrainer" title="Link to this heading"></a></h1>
<p>The <code class="docutils literal notranslate"><span class="pre">MatrixConfigurationTrainer</span></code> learns a set of (D) Hermitian matrices ( {A_1, \dots, A_D} ), each of size (N \times N). The initial values of these matrices can significantly impact the training dynamics and final results. The goal of initialization is typically to start with matrices that are:</p>
<ol class="arabic simple">
<li><p><strong>Hermitian:</strong> Satisfying ( A = A^\dagger ). This is crucial as observables in quantum mechanics are represented by Hermitian operators.</p></li>
<li><p><strong>Reasonably Scaled:</strong> Avoiding extremely large or small initial norms can help with numerical stability and optimizer performance. Normalizing to ( |A| = 1 ) is a common choice.</p></li>
<li><p><strong>Sufficiently Random/Unbiased:</strong> Unless specific prior knowledge is available, the initialization shouldn’t strongly bias the matrices towards a particular configuration (e.g., being diagonal or commuting).</p></li>
</ol>
<section id="current-method-init-hermitian-matrix">
<h2>Current Method (<code class="docutils literal notranslate"><span class="pre">_init_hermitian_matrix</span></code>)<a class="headerlink" href="#current-method-init-hermitian-matrix" title="Link to this heading"></a></h2>
<p>The current implementation uses the following steps:</p>
<ol class="arabic simple">
<li><p>Generate a random complex matrix <code class="docutils literal notranslate"><span class="pre">Z</span></code> with elements drawn from a normal distribution, scaled by ( 1/\sqrt{N} ): <code class="docutils literal notranslate"><span class="pre">Z</span> <span class="pre">=</span> <span class="pre">torch.randn(N,</span> <span class="pre">N,</span> <span class="pre">dtype=torch.cfloat)</span> <span class="pre">/</span> <span class="pre">np.sqrt(N)</span></code>.</p></li>
<li><p>Perform QR decomposition: <code class="docutils literal notranslate"><span class="pre">Q,</span> <span class="pre">R</span> <span class="pre">=</span> <span class="pre">torch.linalg.qr(Z)</span></code>. <code class="docutils literal notranslate"><span class="pre">Q</span></code> is now a unitary matrix.</p></li>
<li><p>Construct a Hermitian matrix from the unitary matrix: <code class="docutils literal notranslate"><span class="pre">H</span> <span class="pre">=</span> <span class="pre">0.5</span> <span class="pre">*</span> <span class="pre">(Q</span> <span class="pre">+</span> <span class="pre">Q.conj().T)</span></code>. This effectively takes the “Hermitian part” of <code class="docutils literal notranslate"><span class="pre">Q</span></code>.</p></li>
<li><p>Normalize the resulting matrix: <code class="docutils literal notranslate"><span class="pre">H</span> <span class="pre">=</span> <span class="pre">H</span> <span class="pre">/</span> <span class="pre">torch.norm(H)</span></code>.</p></li>
<li><p>Assertions are included to verify Hermiticity, normalization, and real eigenvalues.</p></li>
</ol>
<ul class="simple">
<li><p><strong>Pros:</strong> Produces a well-conditioned, normalized, random Hermitian matrix. The use of QR potentially leads to better initial eigenvalue distributions compared to simpler methods.</p></li>
<li><p><strong>Cons:</strong> Slightly more computationally involved than the direct method.</p></li>
</ul>
</section>
<section id="alternative-initialization-methods">
<h2>Alternative Initialization Methods<a class="headerlink" href="#alternative-initialization-methods" title="Link to this heading"></a></h2>
<p>Here are other potential strategies:</p>
<section id="direct-random-hermitian">
<h3>1. Direct Random Hermitian<a class="headerlink" href="#direct-random-hermitian" title="Link to this heading"></a></h3>
<ol class="arabic simple">
<li><p>Generate a random complex matrix <code class="docutils literal notranslate"><span class="pre">Z</span></code> (e.g., <code class="docutils literal notranslate"><span class="pre">torch.randn(N,</span> <span class="pre">N,</span> <span class="pre">dtype=torch.cfloat)</span></code>).</p></li>
<li><p>Make it Hermitian: <code class="docutils literal notranslate"><span class="pre">H</span> <span class="pre">=</span> <span class="pre">0.5</span> <span class="pre">*</span> <span class="pre">(Z</span> <span class="pre">+</span> <span class="pre">Z.conj().T)</span></code>.</p></li>
<li><p>Optionally normalize: <code class="docutils literal notranslate"><span class="pre">H</span> <span class="pre">=</span> <span class="pre">H</span> <span class="pre">/</span> <span class="pre">torch.norm(H)</span></code>.</p></li>
</ol>
<ul class="simple">
<li><p><strong>Pros:</strong> Simpler than the QR method.</p></li>
<li><p><strong>Cons:</strong> May have slightly different initial properties (e.g., eigenvalue distribution) compared to the QR method.</p></li>
</ul>
</section>
<section id="diagonal-matrix">
<h3>2. Diagonal Matrix<a class="headerlink" href="#diagonal-matrix" title="Link to this heading"></a></h3>
<ol class="arabic simple">
<li><p>Generate random <em>real</em> numbers for the diagonal: <code class="docutils literal notranslate"><span class="pre">diag_elements</span> <span class="pre">=</span> <span class="pre">torch.randn(N)</span></code>.</p></li>
<li><p>Create the diagonal matrix: <code class="docutils literal notranslate"><span class="pre">H</span> <span class="pre">=</span> <span class="pre">torch.diag(diag_elements)</span></code>.</p></li>
</ol>
<ul class="simple">
<li><p><strong>Pros:</strong> Very simple, guaranteed Hermitian. Initial matrices commute (<code class="docutils literal notranslate"><span class="pre">[A_i,</span> <span class="pre">A_j]</span> <span class="pre">=</span> <span class="pre">0</span></code>), leading to zero initial commutation penalty.</p></li>
<li><p><strong>Cons:</strong> Might be a poor starting point if the target matrices require significant off-diagonal elements or non-commuting behavior.</p></li>
</ul>
</section>
<section id="scaled-identity-matrix">
<h3>3. Scaled Identity Matrix<a class="headerlink" href="#scaled-identity-matrix" title="Link to this heading"></a></h3>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">H</span> <span class="pre">=</span> <span class="pre">c</span> <span class="pre">*</span> <span class="pre">torch.eye(N,</span> <span class="pre">dtype=torch.cfloat)</span></code>, where <code class="docutils literal notranslate"><span class="pre">c</span></code> is a constant (e.g., 1 or <code class="docutils literal notranslate"><span class="pre">1/sqrt(N)</span></code>).</p></li>
</ol>
<ul class="simple">
<li><p><strong>Pros:</strong> Simplest possible initialization. Hermitian and commuting.</p></li>
<li><p><strong>Cons:</strong> Very restrictive, likely hinders learning unless the target configuration is trivial.</p></li>
</ul>
</section>
<section id="known-algebra-generators">
<h3>4. Known Algebra Generators<a class="headerlink" href="#known-algebra-generators" title="Link to this heading"></a></h3>
<ol class="arabic simple">
<li><p>If the target geometry is known to correspond to a specific Lie algebra (e.g., SU(2) for a fuzzy sphere), initialize matrices based on the standard generators of that algebra’s representation of dimension <code class="docutils literal notranslate"><span class="pre">N</span></code> (e.g., Pauli matrices for N=2, Gell-Mann matrices for N=3). Careful mapping between the <code class="docutils literal notranslate"><span class="pre">D</span></code> coordinate matrices and the algebra generators is needed.</p></li>
</ol>
<ul class="simple">
<li><p><strong>Pros:</strong> Starts the matrices potentially satisfying (or close to) the correct commutation relations. Can significantly speed up convergence if the assumption about the algebra is correct.</p></li>
<li><p><strong>Cons:</strong> Requires specific prior knowledge. Less general.</p></li>
</ul>
</section>
<section id="near-diagonal-near-identity">
<h3>5. Near-Diagonal / Near-Identity<a class="headerlink" href="#near-diagonal-near-identity" title="Link to this heading"></a></h3>
<ol class="arabic simple">
<li><p>Start with a diagonal or identity matrix (methods 2 or 3).</p></li>
<li><p>Add small random Hermitian noise (e.g., using method 1 with a small scaling factor applied to the noise term <code class="docutils literal notranslate"><span class="pre">Z</span></code>).</p></li>
</ol>
<ul class="simple">
<li><p><strong>Pros:</strong> Allows for slight deviation from the simple commuting structures.</p></li>
<li><p><strong>Cons:</strong> Still potentially biased towards nearly commuting matrices.</p></li>
</ul>
</section>
</section>
<section id="considerations">
<h2>Considerations<a class="headerlink" href="#considerations" title="Link to this heading"></a></h2>
<p>The choice of initialization can affect:</p>
<ul class="simple">
<li><p><strong>Convergence Speed:</strong> Starting closer to the solution (e.g., using known algebra generators) can speed up training.</p></li>
<li><p><strong>Final Solution:</strong> Different initializations might lead the optimizer to different local minima.</p></li>
<li><p><strong>Numerical Stability:</strong> Poorly scaled or conditioned initial matrices can cause issues.</p></li>
</ul>
<p>The current QR-based method provides a good general-purpose random initialization.</p>
</section>
<section id="maintaining-hermiticity-during-training-make-matrices-hermitian">
<h2>Maintaining Hermiticity During Training (<code class="docutils literal notranslate"><span class="pre">_make_matrices_hermitian</span></code>)<a class="headerlink" href="#maintaining-hermiticity-during-training-make-matrices-hermitian" title="Link to this heading"></a></h2>
<p>It’s important to note that standard gradient descent optimizers (like Adam) do not inherently preserve the Hermitian property of the matrices. An update step might introduce a non-Hermitian component.</p>
<p>To counteract this, the <code class="docutils literal notranslate"><span class="pre">_make_matrices_hermitian</span></code> method is called <em>after</em> each optimizer step during training. This method projects the potentially non-Hermitian matrix <code class="docutils literal notranslate"><span class="pre">A_prime</span></code> back onto the space of Hermitian matrices <code class="docutils literal notranslate"><span class="pre">A</span></code> using the formula:</p>
<p>[ A = \frac{1}{2} (A_{\text{prime}} + A_{\text{prime}}^\dagger) ]</p>
<p>This is implemented as <code class="docutils literal notranslate"><span class="pre">H</span> <span class="pre">=</span> <span class="pre">0.5</span> <span class="pre">*</span> <span class="pre">(self.matrices[i].data</span> <span class="pre">+</span> <span class="pre">self.matrices[i].data.conj().transpose(-2,</span> <span class="pre">-1))</span></code>.</p>
<p>Notice that this projection formula is the same core idea used in the “Direct Random Hermitian” initialization (Method 1) and also in the current QR-based method to construct <code class="docutils literal notranslate"><span class="pre">H</span></code> from <code class="docutils literal notranslate"><span class="pre">Q</span></code>. This projection ensures that the matrices used for subsequent calculations (like computing the Hamiltonian, ground state, and loss components) remain Hermitian, which is essential for physical consistency and numerical stability (preventing issues like negative quantum fluctuations).</p>
<p>The method also re-normalizes the matrix (<code class="docutils literal notranslate"><span class="pre">H</span> <span class="pre">=</span> <span class="pre">H</span> <span class="pre">/</span> <span class="pre">torch.norm(H)</span></code>) after the projection to maintain consistent scaling.</p>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, QGML Research Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>